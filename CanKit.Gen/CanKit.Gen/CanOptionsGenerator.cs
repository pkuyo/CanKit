using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CanKit.Gen;

public enum CanOptionType
{
    Init = 1,
    Runtime = 2
}

[Generator(LanguageNames.CSharp)]
public sealed class CanOptionsGenerator : IIncrementalGenerator
{
    private const string OptionAttrFull = "CanKit.Core.Attributes.CanOptionAttribute";
    private const string OptionAttrShort = "CanOptionAttribute";
    private const string ParamAttrFull = "CanKit.Core.Attributes.CanOptionItemAttribute";
    private const string ParamAttrShort = "CanOptionItemAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 找到被 [CanOption] 标注的 partial 类型
        var candidates = context.SyntaxProvider.CreateSyntaxProvider(
            static (node, _) =>
                node is TypeDeclarationSyntax t &&
                t.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword)) &&
                t.AttributeLists.Count > 0,
            static (ctx, ct) => Transform(ctx, ct)
        ).Where(static t => t is not null)!;

        var combo = context.CompilationProvider.Combine(candidates.Collect());

        context.RegisterSourceOutput(combo, static (spc, tuple) =>
        {
            var (compilation, items) = (tuple.Left, tuple.Right);
            if (items.Length == 0) return;

            foreach (var item in items!)
            {
                Emit(spc, compilation, item!);
            }
        });
    }

    private static TypeWork? Transform(GeneratorSyntaxContext ctx, System.Threading.CancellationToken ct)
    {
        var typeDecl = (TypeDeclarationSyntax)ctx.Node;
        var symbol = ctx.SemanticModel.GetDeclaredSymbol(typeDecl, ct);
        if (symbol is null) return null;

        if (!HasAttr(symbol, OptionAttrFull, OptionAttrShort)) return null;

        // 收集：实例属性 + [CanOptionItem]（不再要求 partial/auto-property）
        var list = new List<PropertyWork>();
        foreach (var member in typeDecl.Members.OfType<PropertyDeclarationSyntax>())
        {
            var propSymbol = ctx.SemanticModel.GetDeclaredSymbol(member, ct) as IPropertySymbol;
            if (propSymbol is null || propSymbol.IsStatic) continue;

            var attr = GetAttr(propSymbol, ParamAttrFull, ParamAttrShort);
            if (attr == null || attr.ConstructorArguments.Any(i => i.Kind == TypedConstantKind.Error))
                continue;

            var hasGet = propSymbol.GetMethod is not null;
            var hasSet = propSymbol.SetMethod is not null &&
                         propSymbol.SetMethod.DeclaredAccessibility != Accessibility.NotApplicable;
            var isInit = member.AccessorList?.Accessors.Any(a =>
                a.Kind() == SyntaxKind.InitAccessorDeclaration) == true;

            list.Add(new PropertyWork(
                Name: propSymbol.Name,
                TypeDisplay: propSymbol.Type.ToDisplayString(
                    SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(
                        SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier)),
                HasGet: hasGet,
                HasSet: hasSet,
                Accessibility: propSymbol.DeclaredAccessibility,
                HasModifers: member.Modifiers.Any(m =>
                    m.IsKind(SyntaxKind.PublicKeyword) ||
                    m.IsKind(SyntaxKind.PrivateKeyword) ||
                    m.IsKind(SyntaxKind.ProtectedKeyword) ||
                    m.IsKind(SyntaxKind.InternalKeyword)),
                UseInit: isInit,
                OptionName: (string)attr.ConstructorArguments[0].Value!,
                OptionType: (CanOptionType)((int)attr.ConstructorArguments[1].Value!),
                DefaultValue: attr.ConstructorArguments.Length > 2
                    ? attr.ConstructorArguments[2].Value as string
                    : null
            ));
        }

        return new TypeWork(symbol, list);
    }

    private static AttributeData? GetAttr(ISymbol symbol, string full, string shortName)
        => symbol.GetAttributes().FirstOrDefault(a =>
            a.AttributeClass?.ToDisplayString() == full
            || a.AttributeClass?.Name == shortName);

    private static bool HasAttr(ISymbol symbol, string full, string shortName)
        => GetAttr(symbol, full, shortName) != null;

    private static void Emit(SourceProductionContext spc, Compilation compilation, TypeWork work)
    {
        var ns = work.TypeSymbol.ContainingNamespace?.IsGlobalNamespace == true
            ? null
            : work.TypeSymbol.ContainingNamespace?.ToDisplayString();

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.CodeDom.Compiler;");
        sb.AppendLine("using System.Collections;");
        sb.AppendLine("using System.Collections.Generic;");

        if (ns is not null)
        {
            sb.Append("namespace ").Append(ns).AppendLine(";");
            sb.AppendLine();
        }

        // 打开嵌套的 partial 类型
        var stack = new Stack<INamedTypeSymbol>();
        var cur = work.TypeSymbol;
        while (cur is not null)
        {
            stack.Push(cur);
            cur = cur.ContainingType;
        }

        foreach (var t in stack)
        {
            var kw = t.TypeKind switch
            {
                TypeKind.Struct => "struct",
                TypeKind.Class => "class",
                TypeKind.Interface => "interface",
                _ => "class"
            };
            sb.Append("partial ").Append(kw).Append(' ').Append(t.Name);

            if (t.Arity > 0)
            {
                sb.Append('<');
                for (int i = 0; i < t.TypeArguments.Length; i++)
                {
                    if (i > 0) sb.Append(", ");
                    sb.Append(t.TypeArguments[i].Name);
                }
                sb.Append('>');
            }

            sb.AppendLine();
            sb.AppendLine("{");
        }

        // 验证 + 生成 backing 字段、partial 方法实现
        var available = new List<PropertyWork>();
        var index = 0;

        foreach (var p in work.Properties)
        {
            if (!p.HasGet || !p.HasSet)
            {
                var descriptor = new DiagnosticDescriptor(
                    id: "CANG001",
                    title: "属性缺少 get/set",
                    messageFormat: "{0}.{1} 缺少 {2}",
                    category: "SourceGenerator",
                    DiagnosticSeverity.Error,
                    isEnabledByDefault: true
                );
                var miss = (!p.HasGet ? "Get" : "") + (!p.HasSet ? (string.IsNullOrEmpty((!p.HasGet ? "Get" : "")) ? "Set" : "/Set") : "");
                spc.ReportDiagnostic(Diagnostic.Create(descriptor, Location.None,
                    work.TypeSymbol.Name, p.Name, miss));
                continue;
            }

            if (p.Accessibility == Accessibility.NotApplicable && p.HasModifers)
            {
                var descriptor = new DiagnosticDescriptor(
                    id: "CANG002",
                    title: "属性访问权限错误",
                    messageFormat: "{0}.{1} 访问权限描述符错误",
                    category: "SourceGenerator",
                    DiagnosticSeverity.Error,
                    isEnabledByDefault: true
                );
                spc.ReportDiagnostic(Diagnostic.Create(descriptor, Location.None,
                    work.TypeSymbol.Name, p.Name));
                continue;
            }

            available.Add(p);

            var backing = MakeBackingName(p.Name);

            // backing field
            sb.Append("    private ").Append(p.TypeDisplay).Append(' ').Append(backing);
            if (p.DefaultValue != null) sb.Append(" = ").Append(p.DefaultValue);
            sb.AppendLine(";");

            // Get_ 方法
            sb.Append("    private ").Append(p.TypeDisplay)
              .Append(" Get_").Append(p.Name).AppendLine("()");
            sb.AppendLine("    {");
            sb.Append("        return this.").Append(backing).AppendLine(";");
            sb.AppendLine("    }");

            // Set_/Init 方法
            var setterName = "Set_" + p.Name;
            sb.Append("    private void ").Append(setterName)
              .Append("(").Append(p.TypeDisplay).Append(" value)").AppendLine();
            sb.AppendLine("    {");
            // 用 EqualityComparer<T>.Default 提升兼容性
            sb.Append("        if (!EqualityComparer<").Append(p.TypeDisplay).Append(">")
              .Append(".Default.Equals(this.").Append(backing).Append(", value))").AppendLine();
            sb.AppendLine("        {");
            sb.Append("            this.").Append(backing).AppendLine(" = value;");
            sb.Append("            this._hasChanged[").Append(index).AppendLine("] = true;");
            sb.AppendLine("        }");
            sb.AppendLine("    }");

            sb.AppendLine();
            index++;
        }

        sb.AppendLine();
        sb.Append("    private BitArray _hasChanged = new BitArray(")
          .Append(available.Count).AppendLine(");");
        sb.AppendLine();

        // Apply 方法
        sb.AppendLine("    public partial void Apply(CanKit.Core.Abstractions.ICanApplier applier, bool force)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (applier is CanKit.Core.Abstractions.INamedCanApplier namedApplier)");
        sb.AppendLine("        {");
        for (int i = 0; i < available.Count; i++)
        {
            var p = available[i];
            var backing = MakeBackingName(p.Name);
            sb.Append("            if ((_hasChanged[").Append(i).Append("] || force)")
              .Append(" && namedApplier.ApplierStatus == CanKit.Core.Definitions.CanOptionType.")
              .Append(p.OptionType).AppendLine()
              .Append("                && namedApplier.ApplyOne<").Append(p.TypeDisplay).Append(">(")
              .Append('"').Append(p.OptionName).Append('"').Append(", ").Append(backing).Append("))")
              .AppendLine()
              .AppendLine("                _hasChanged[" + i + "] = false;");
        }
        sb.AppendLine("        }");
        sb.AppendLine("        applier.Apply(this);");
        sb.AppendLine("    }");

        // 关闭嵌套
        for (int i = 0; i < stack.Count; i++)
            sb.AppendLine("}");

        var hintName = "CanOption." + work.TypeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            .Replace("global::", string.Empty)
            .Replace('<', '_').Replace('>', '_')
            .Replace('.', '_').Replace('+', '_') + ".g.cs";

        spc.AddSource(hintName, sb.ToString());
    }

    private static string MakeBackingName(string propName)
    {
        if (string.IsNullOrEmpty(propName)) return "__can_item_";
        var first = char.ToLowerInvariant(propName[0]);
        var rest = propName.Length > 1 ? propName.Substring(1) : "";
        return $"__can_item_{first}{rest}";
    }

    private sealed record PropertyWork(
        string Name,
        string TypeDisplay,
        bool HasGet,
        bool HasSet,
        Accessibility Accessibility,
        bool HasModifers,
        bool UseInit,
        string OptionName,
        CanOptionType OptionType,
        string? DefaultValue = null
    );

    private sealed record TypeWork(INamedTypeSymbol TypeSymbol, IReadOnlyList<PropertyWork> Properties);
}
